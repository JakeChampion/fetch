// Generated by CoffeeScript 1.9.1
(function() {
  var Body, Headers, Request, Response, consumed, decode, e, fileReaderReady, headers, methods, normalizeMethod, normalizeName, normalizeValue, readBlobAsArrayBuffer, readBlobAsText, support,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  if (self.fetch) {
    return;
  }


  /*
  #
   * Body
  #
   */

  Body = (function() {
    function Body() {
      this.bodyUsed = false;
      this._initBody = function(body) {
        this._bodyInit = body;
        if (typeof body === 'string') {
          return this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          return this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          return this._bodyFormData = body;
        } else if (!body) {
          return this._bodyText = '';
        } else {
          throw new Error('unsupported BodyInit type');
        }
      };
      if (support.blob) {
        this.blob = function() {
          if (consumed(this)) {
            return true;
          }
          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };
        this.arrayBuffer = function() {
          return this.blob().then(readBlobAsArrayBuffer);
        };
      }
      if (support.formData) {
        this.formData = function() {
          return this.text().then(decode);
        };
      }
      this.json = function() {
        return this.text().then(JSON.parse);
      };
      this.text = function() {
        if (consumed(this)) {
          return true;
        }
        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };
    }

    return Body;

  })();


  /*
  #
   * Headers
  #
   */

  Headers = (function() {
    function Headers(headers) {
      this.map = {};
      if (headers instanceof Headers) {
        headers.forEach(function(name, values) {
          return values.forEach(function(value) {
            return this.append(name, value);
          });
        });
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach((function(_this) {
          return function(name) {
            return _this.append(name, headers[name]);
          };
        })(this));
      }
    }

    Headers.prototype.append = function(name, value) {
      var ref;
      name = normalizeName(name);
      value = normalizeValue(value);
      this.map[name] = (ref = this.map[name]) != null ? ref : [];
      if (indexOf.call(this.map[name], value) < 0) {
        return this.map[name].push(value);
      }
    };

    Headers.prototype['delete'] = function(name) {
      return delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function(name) {
      var values;
      values = this.map[normalizeName(name)];
      if (values) {
        return values[0];
      } else {
        return null;
      }
    };

    Headers.prototype.getAll = function(name) {
      return this.map[normalizeName(name)] || [];
    };

    Headers.prototype.has = function(name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function(name, value) {
      return this.map[normalizeName(name)] = [normalizeValue(value)];
    };

    Headers.prototype.forEach = function(callback) {
      return Object.getOwnPropertyNames(this.map).forEach((function(_this) {
        return function(name) {
          return callback(name, _this.map[name]);
        };
      })(this));
    };

    return Headers;

  })();


  /*
  #
   * Request
   * (extends Body)
  #
   */

  Request = (function(superClass) {
    extend(Request, superClass);

    function Request(url, options) {
      var ref;
      Request.__super__.constructor.call(this);
      options = options != null ? options : {};
      this.url = url;
      this.credentials = options.credentials || 'omit';
      this.headers = new Headers(options.headers);
      this.method = normalizeMethod(options.method || 'GET');
      this.mode = options.mode || null;
      this.referrer = null;
      if (((ref = this.method) === 'GET' || ref === 'HEAD') && options.body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }
      this._initBody(options.body);
    }

    Request.prototype.fetch = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var responseURL, xhr;
          xhr = new XMLHttpRequest();
          if (_this.credentials === 'cors') {
            xhr.withCredentials = true;
          }
          responseURL = function() {
            var isHeadersGetter;
            if ('responseURL' in xhr) {
              return xhr.responseURL;
            }
            isHeadersGetter = /^X-Request-URL:/m.test(xhr.getAllResponseHeaders());
            if (isHeadersGetter) {
              return xhr.getResponseHeader('X-Request-URL');
            }
          };
          xhr.onload = function() {
            var body, options, status;
            status = xhr.status === 1223 ? 204 : xhr.status;
            if (status < 100 || status > 599) {
              reject(new TypeError('Network request failed'));
              return;
            }
            options = {
              status: status,
              statusText: xhr.statustext,
              headers: headers(xhr),
              url: responseURL()
            };
            body = 'response' in xhr ? xhr.response : xhr.responseText;
            return resolve(new Response(body, options));
          };
          xhr.onerror = function() {
            return reject(new TypeError('Network request failed'));
          };
          xhr.open(_this.method, _this.url, true);
          if ('responseType' in xhr && support.blob) {
            xhr.responseType = 'blob';
          }
          _this.headers.forEach(function(name, values) {
            return values.forEach(function(value) {
              return xhr.setRequestHeader(name, value);
            });
          });
          return xhr.send(typeof _this._bodyInit === 'undefined' ? null : _this._bodyInit);
        };
      })(this));
    };

    return Request;

  })(Body);


  /*
  #
   * Response
   * (extends Body)
  #
   */

  Response = (function(superClass) {
    extend(Response, superClass);

    function Response(bodyInit, options) {
      Response.__super__.constructor.call(this);
      options = options != null ? options : {};
      this._initBody(bodyInit);
      this.type = 'default';
      this.url = null;
      this.status = options.status;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = options.statusText;
      this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      this.url = options.url || '';
    }

    return Response;

  })(Body);


  /*
  #
   * Functions
  #
   */

  normalizeName = function(name) {
    if (typeof name !== 'string') {
      name = name.toString();
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  };

  normalizeValue = function(value) {
    return value = typeof value === 'string' ? value : value.toString();
  };

  consumed = function(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    } else {
      body.bodyUsed = true;
      return false;
    }
  };

  fileReaderReady = function(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        return resolve(reader.result);
      };
      return reader.onerror = function() {
        return reject(reader.error);
      };
    });
  };

  readBlobAsArrayBuffer = function(blob) {
    var reader;
    reader = new FileReader();
    reader.readAsArrayBuffer(blob);
    return fileReaderReady(reader);
  };

  readBlobAsText = function(blob) {
    var reader;
    reader = new FileReader();
    reader.readAsText(blob);
    return fileReaderReady(reader);
  };

  support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true;
      } catch (_error) {
        e = _error;
        return false;
      }
    })(),
    formData: 'FormData' in self
  };

  methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  normalizeMethod = function(method) {
    var upcased;
    upcased = method.toUpperCase();
    if (indexOf.call(methods, upcased) >= 0) {
      return upcased;
    } else {
      return method;
    }
  };

  decode = function(body) {
    var bytes, fn, form, i, len, ref;
    form = new FormData();
    ref = body.trim().split('&');
    fn = function(bytes) {
      var name, split, value;
      if (bytes) {
        split = bytes.split('=');
        name = split.shift().replace(/\+/g, ' ');
        value = split.join('=').replace(/\+/g, ' ');
        return form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    };
    for (i = 0, len = ref.length; i < len; i++) {
      bytes = ref[i];
      fn(bytes);
    }
    return form;
  };

  headers = function(xhr) {
    var fn, head, header, i, len, pairs;
    head = new Headers();
    pairs = xhr.getAllResponseHeaders().trim().split('\n');
    fn = function(header) {
      var key, split, value;
      split = header.trim().split(':');
      key = split.shift().trim();
      value = split.join(':').trim();
      return head.append(key, value);
    };
    for (i = 0, len = pairs.length; i < len; i++) {
      header = pairs[i];
      fn(header);
    }
    return head;
  };

  this.Headers = Headers;

  this.Request = Request;

  this.Response = Response;

  this.fetch = function(url, options) {
    return new Request(url, options).fetch();
  };

  this.fetch.polyfill = true;

}).call(this);
